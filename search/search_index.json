{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Getting started","text":"<p>This package is a monadic approach to data validation to easily compose validations rules.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>composer require innmind/validation\n</code></pre>"},{"location":"philosophy/","title":"Philosophy","text":"<p>In this package a validation rule is called a <code>Constraint</code>.</p> <p>All constraints are immutable objects. This means that you can compose them any way you want safely.</p> <p>Unlike most validation packages, here you can directly apply transformation on each validated value (1). This brings 2 benefits:</p> <ol> <li>via the <code>-&gt;map()</code> methods</li> </ol> <ul> <li>no need to write <code>if</code>s after validation when transforming the data to please static analysis tools</li> <li>no need to have classes that look like valid data just to declare validations rules</li> </ul> <p>This helps have a clear separation between declaring the expected structure (1) and the execution.</p> <ol> <li>both the input and the output</li> </ol> <p>Another benefit of contraints being immutable objects is that there's no central validator object. This means that anyone can create its own <code>Constraint</code> and use it directly.</p>"},{"location":"constraints/","title":"Constraints","text":"<p>Each <code>Constraint</code> have the following methods:</p> <ul> <li><code>-&gt;__invoke()</code></li> <li><code>-&gt;and()</code></li> <li><code>-&gt;guard()</code></li> <li><code>-&gt;or()</code></li> <li><code>-&gt;xor()</code></li> <li><code>-&gt;map()</code></li> <li><code>-&gt;asPredicate()</code></li> <li><code>-&gt;failWith()</code></li> </ul>"},{"location":"constraints/#-__invoke","title":"<code>-&gt;__invoke()</code>","text":"<p>This method is the one to apply the validation on an input and will return a <code>Validation</code> monad that will contain either the validated data or the error messages.</p> <p>Let's take a simple example to check if the input of a method is a <code>string</code>:</p> <pre><code>use Innmind\\Validation\\Is;\n\nfunction(mixed $input): string {\n    $validate = Is::string();\n\n    return $validate($input)-&gt;match(\n        static fn(string $value) =&gt; $value,\n        static fn() =&gt; throw new \\RuntimeException('Input is not a string');\n    );\n}\n</code></pre> Info <p>Note that we use the style <code>$validate($input)</code> and not <code>$validate-&gt;__invoke($input)</code>. This style allows to treat the constraints as if it were native functions.</p>"},{"location":"constraints/#-and","title":"<code>-&gt;and()</code>","text":"<p>This method allows to apply extra validation on an input.</p> <p>Let's take the example of making sure a <code>string</code> is shorter than <code>255</code> characters:</p> <pre><code>use Innmind\\Validation\\{\n    Is,\n    Constraint,\n    Failure,\n};\nuse Innmind\\Immutable\\Validation;\n\nfunction(mixed $input): string {\n    $validate = Is::string()-&gt;and(Constraint::of(\n        static fn(string $value) =&gt; match (true) {\n            \\strlen($value) &lt; 255 =&gt; Validation::success($value),\n            default =&gt; Validation::fail(Failure::of('String is too long')),\n        },\n    ));\n\n    return $validate($input)-&gt;match(\n        static fn(string $value) =&gt; $value,\n        static fn() =&gt; throw new \\RuntimeException('Input is not valid');\n    );\n}\n</code></pre>"},{"location":"constraints/#-guard","title":"<code>-&gt;guard()</code>","text":"<p>This is like <code>-&gt;and()</code> except that the failures of the constraint passed as argument won't be recovered by a call to <code>-&gt;xor()</code>.</p>"},{"location":"constraints/#-or","title":"<code>-&gt;or()</code>","text":"<p>This method allows to have an alternate validation in case the first one fails. This is useful for unions types.</p> <p>Let's take the example where the input needs to be a <code>string</code> or an <code>int</code>:</p> <pre><code>use Innmind\\Validation\\Is;\n\nfunction(mixed $input): string|int {\n    $validate = Is::string()-&gt;or(Is::int());\n\n    return return $validate($input)-&gt;match(\n        static fn(string|int $value) =&gt; $value,\n        static fn() =&gt; throw new \\RuntimeException('Input is not valid'),\n    );\n}\n</code></pre>"},{"location":"constraints/#-xor","title":"<code>-&gt;xor()</code>","text":"<pre><code>use Innmind\\Validation\\Is;\n\n$validate = Is::string()\n    -&gt;guard(Is::value('foobar'))\n    -&gt;xor(Is::int());\n$validate($value)-&gt;match(\n    static fn(string|int $value) =&gt; $value,\n    static fn() =&gt; throw new \\RuntimeException('Input is not valid'),\n);\n</code></pre> <p>Unlike <code>-&gt;or()</code>, if <code>$value</code> is any string other than <code>foobar</code> this will raise an exception. This is because the failure due to <code>Is::value('foobar')</code> is guarded.</p> <p>This is the only combination preventing a failure from being recovered. Replacing <code>-&gt;guard()</code> by <code>-&gt;and()</code> or <code>-&gt;xor()</code> by <code>-&gt;or()</code> will work the same way as <code>-&gt;and()-&gt;or()</code>.</p>"},{"location":"constraints/#-map","title":"<code>-&gt;map()</code>","text":"<p>This method allows to transform the validated value to anything you want.</p> <p>Let's take the example where a need a <code>string</code> but want to output a <code>Str</code> for ease of use afterwards:</p> <pre><code>use Innmind\\Validation\\Is;\nuse Innmind\\Immutable\\Str;\n\nfunction(mixed $input): Str {\n    $validate = Is::string()-&gt;map(\n        static fn(string $value) =&gt; Str::of($value),\n    );\n\n    return return $validate($input)-&gt;match(\n        static fn(Str $value) =&gt; $value,\n        static fn() =&gt; throw new \\RuntimeException('Input is not valid');\n    );\n}\n</code></pre>"},{"location":"constraints/#-aspredicate","title":"<code>-&gt;asPredicate()</code>","text":"<p>A <code>Predicate</code> acts as a function that returns a <code>bool</code>.</p> <p>It's intended to be used with <code>Sequence::keep()</code> or <code>Set::keep()</code>.</p> <p>Here's an example to keep all <code>string</code>s inside a <code>Sequence</code>:</p> <pre><code>use Innmind\\Validation\\Is;\nuse Innmind\\Immutable\\Sequence;\n\nSequence::of(1, 'a', null, 'b', new \\stdClass, 'c')\n    -&gt;keep(Is::string()-&gt;asPredicate())\n    -&gt;toList(); // returns ['a', 'b', 'c']\n</code></pre> Note <p>There's no need to apply transformations on your constraints when used as predicates as the outputed value is not used.</p>"},{"location":"constraints/#-failwith","title":"<code>-&gt;failWith()</code>","text":"<p>This method allows to change the failure message.</p> <pre><code>use Innmind\\Validation\\Is;\n\n$password = Is::string()-&gt;failWith('The password is required');\n\n$password($someInput);\n</code></pre>"},{"location":"constraints/#handling-failures","title":"Handling failures","text":"<p>In the examples above we've thrown exceptions in case of errors but you have access to all the failures messages and where they happened.</p> <pre><code>use Innmind\\Validation\\{\n    Is,\n    Failure,\n};\nuse Innmind\\Immutable\\Sequence;\n\n$validate = Is::shape('id', Is::int())\n    -&gt;with('username', Is::string());\n\n$validate($input)-&gt;match(\n    static fn(array $valid) =&gt; $valid,\n    static fn(Sequence $failures) =&gt; \\var_dump(\n        $failures\n            -&gt;map(static fn(Failure $failure) =&gt; [\n                $failure-&gt;path()-&gt;toString(),\n                $failure-&gt;message(),\n            ])\n            -&gt;toList(),\n    ),\n);\n</code></pre> <p>In case <code>$input</code> is invalid it will print:</p> Not an <code>array</code><code>[]</code><code>['id' =&gt; 'wrong', 'username' =&gt; false]</code> <pre><code>[['$', 'Value is not of type array']]\n</code></pre> <pre><code>[\n    ['$', 'The key id is missing'],\n    ['$', 'The key username is missing'],\n]\n</code></pre> <pre><code>[\n    ['id', 'Value is not of type int'],\n    ['username', 'Value is not of type string'],\n]\n</code></pre>"},{"location":"constraints/array-shapes/","title":"Array shape","text":"<p>Unlike an associative array, a shape is an array where the keys are known in advance.</p> <pre><code>use Innmind\\Validation\\Is;\n\n$validate = Is::shape('id', Is::int())\n    -&gt;with('username', Is::string());\n</code></pre> <p>This contraint will accept any array that looks like:</p> <pre><code>[\n    'id' =&gt; 42, #(1)\n    'username' =&gt; 'any string',\n]\n</code></pre> <ol> <li>or any <code>int</code></li> </ol> <p>If the input data contains more keys than the expected ones, the output will only contains the keys you specified. This is to prevent any unwanted data injection in your code.</p>"},{"location":"constraints/array-shapes/#optional-keys","title":"Optional keys","text":"<p>Here's an example of a login payload where the \"Keep me logged in\" is optional:</p> <pre><code>use Innmind\\Validation\\Is;\n\n$validate = Is::shape('username', Is::string())\n    -&gt;with('password', Is::string())\n    -&gt;optional('keep-logged-in', Is::string());\n</code></pre> <p>The optional key will only be present in the output value if it was set in the input.</p> Tip <p>If you want to build a shape with a single optional key you can do <code>Is::shape('key', Is::string())-&gt;optional('key')</code>.</p> <p>If you don't want to handle the possible absence of the key in the output array you can specify a default value:</p> <pre><code>use Innmind\\Validation\\Is;\n\n$validate = Is::shape('username', Is::string())\n    -&gt;with('password', Is::string())\n    -&gt;optional('keep-logged-in', Is::string())\n    -&gt;default('keep-logged-in', 'false');\n</code></pre>"},{"location":"constraints/array-shapes/#rename-a-key","title":"Rename a key","text":"<p>This is useful when the output value no longer matches the input key name.</p> <p>For example you have a shape containing a list of integers but you want the highest one:</p> <pre><code>use Innmind\\Validation\\Is;\n\n$validate = Is::shape(\n    'versions',\n    Is::list(Is::int())\n        -&gt;map(\\max(...)),\n)-&gt;rename('versions', 'highest');\n</code></pre> <p>Now the output type is <code>array{highest: int}</code>.</p>"},{"location":"constraints/associative-arrays/","title":"Associative arrays","text":"<p>Here's the constraint to validate the HTTP response https://packagist.org/packages/list.json?vendor=innmind&amp;fields[]=repository&amp;fields[]=abandoned:</p> <pre><code>use Innmind\\Validation\\Is;\n\n$validate = Is::array()-&gt;associative(\n    Is::string(),\n    Is::shape('repository', Is::string())\n        -&gt;with('abandoned', Is::bool()-&gt;or(Is::string())),\n);\n</code></pre>"},{"location":"constraints/custom/","title":"Custom","text":"<p>At some point you'll want to use your own constraints for a custom business logic. You can do:</p> <pre><code>use Innmind\\Validation\\{\n    Constraint,\n    Failure,\n};\nuse Innmind\\Immutable\\Validation;\n\n$validate = Constraint::of(static function(mixed $input) {\n    if (/* your validation here */) {\n        return Validation::success($input);\n    }\n\n    return Validation::fail(Failure::of('Your error message'));\n});\n</code></pre> <p>And you can still compose it with any other constraint.</p> <p>For example if you know the input has to be a <code>string</code> you can do:</p> <pre><code>use Innmind\\Validation\\{\n    Constraint,\n    Failure,\n};\nuse Innmind\\Immutable\\Validation;\n\n$validate = Is::string()-&gt;and(Constraint::of(static function(string $input) {\n    if (/* your validation here */) {\n        return Validation::success($input);\n    }\n\n    return Validation::fail(Failure::of('Your error message'));\n}));\n</code></pre> <p>You don't need to write all the validations yourself in the <code>callable</code>.</p>"},{"location":"constraints/dates/","title":"Dates","text":"<p>This will transform <code>string</code>s into <code>PointInTime</code>s from the <code>innmind/time</code> package.</p> <pre><code>use Innmind\\Validation\\Constraint;\nuse Innmind\\Time\\{\n    Clock,\n    Format,\n};\n\n$validate = Constraint::pointInTime(Clock::live())-&gt;format(\n    Format::iso8601(),\n);\n</code></pre> Tip <p>Instead of creating the <code>Clock</code> yourself you should retrieve it from the operating system abstraction.</p>"},{"location":"constraints/maybe/","title":"Maybe monad","text":"<p>If a previous contraint outputs a <code>Maybe</code> and you want to access the inner value you can do:</p> <pre><code>use Innmind\\Validation\\Is;\nuse Innmind\\Immutable\\Maybe;\n\n$validate = Is::int()\n    -&gt;or(Is::null())\n    -&gt;map(Maybe::of(...))\n    -&gt;and(Is::just());\n</code></pre> <p>In this example the input can be an <code>int</code> or <code>null</code> but it will fail the validation in case the value is <code>null</code> because <code>Maybe::of(...)</code> will move the <code>null</code> as a <code>Nothing</code> and we say we want a <code>Just</code>.</p>"},{"location":"constraints/objects/","title":"Objects","text":"<p>You can check the input is an object like this:</p> <pre><code>use Innmind\\Validation\\Constraint;\n\n$validate = Constraint::object();\n</code></pre> <p>And if you want to make sure it is an instance of some class:</p> <pre><code>use Innmind\\Validation\\Instance;\n\n$validate = Instance::of(SomeClass::class);\n</code></pre>"},{"location":"constraints/primitives/","title":"Primitives","text":"<code>string</code><code>non-empty-string</code><code>int</code><code>int&lt;1, max&gt;</code><code>int&lt;min, -1&gt;</code><code>int</code> range<code>float</code><code>array</code><code>bool</code><code>null</code> <pre><code>use Innmind\\Validation\\Is;\n\n$validate = Is::string();\n</code></pre> <pre><code>use Innmind\\Validation\\Is;\n\n$validate = Is::string()-&gt;nonEmpty();\n</code></pre> <pre><code>use Innmind\\Validation\\Is;\n\n$validate = Is::int();\n</code></pre> <pre><code>use Innmind\\Validation\\Is;\n\n$validate = Is::int()-&gt;positive();\n</code></pre> <pre><code>use Innmind\\Validation\\Is;\n\n$validate = Is::int()-&gt;negative();\n</code></pre> <pre><code>use Innmind\\Validation\\Is;\n\n$min = 0;\n$max = 100;\n\n$validate = Is::int()-&gt;range($min, $max);\n</code></pre> <pre><code>use Innmind\\Validation\\Is;\n\n$validate = Is::float();\n</code></pre> <pre><code>use Innmind\\Validation\\Is;\n\n$validate = Is::array();\n</code></pre> <pre><code>use Innmind\\Validation\\Is;\n\n$validate = Is::bool();\n</code></pre> <pre><code>use Innmind\\Validation\\Is;\n\n$validate = Is::null();\n</code></pre> <p>By default the error message will be <code>Value is not of type {primitive}</code>. You can change it via:</p> <pre><code>$validate = Is::string()-&gt;failWith('Some error message');\n</code></pre>"},{"location":"constraints/primitives/#lists","title":"Lists","text":"<p>This constraint validates the input is an <code>array</code> and all values are consecutive (1).</p> <ol> <li>No index value specified, be it <code>int</code>s or <code>string</code>s.</li> </ol> <pre><code>use Innmind\\Validation\\Is;\n\n$validate = Is::list();\n</code></pre> <p>You can also validate that each value in the list is of a given type. Here's how to validate a list of <code>string</code>s:</p> <pre><code>use Innmind\\Validation\\Is;\n\n$validate = Is::list(Is::string());\n</code></pre>"},{"location":"constraints/primitives/#specified-value","title":"Specified value","text":"<p>This constraint makes sure the the input value is the expected one.</p> <pre><code>use Innmind\\Validation\\Is;\n\n$validate = Is::value(42);\n</code></pre> <p>If you call the constraint with any other value than <code>42</code>, the validation will fail. Of course you can specify any value of any type you wish.</p> Tip <p>This is especially useful to define discriminators when the input can be multiple shapes that are defined by a key.</p> <pre><code>use Innmind\\Validation\\Is;\n\n$shapeA = Is::shape('discriminator', Is::value('a'))\n    -&gt;with('some-key', Is::string());\n$shapeB = Is::shape('discriminator', Is::value('b'))\n    -&gt;with('other-key', Is::int());\n\n$validate = $shapeA-&gt;or($shapeB);\n</code></pre> <p>If you can <code>$validate</code> with one of the following values it will succeed:</p> AB <pre><code>[\n    'discriminator' =&gt; 'a',\n    'some-key' =&gt; 'foo',\n]\n</code></pre> <pre><code>[\n    'discriminator' =&gt; 'b',\n    'other-key' =&gt; 42,\n]\n</code></pre> <p>Otherwise it will fail for any other array shape.</p>"}]}